#include <stdio.h>#include <Windows.h>#include <ctype.h>void bufferclear();//입력버퍼를 비우기 위한 함수void inputnum(int *);//홀수 입력을 받는 함수void msmaker(int, int **);//마방진 연산을 위한 함수void show(int, int **);//만든 마방진 출력을 위한 함수void resume();//마방진 출력 후 Y/N을 띄우는 함수void main(){int **Arr;//마방진 제작을 위한 2차원 배열 선언int num;//마방진의 크기를 입력받기 위한 변수for (;;)//무한루프 돌입{inputnum(&num);//마방진의 크기를 입력받음Arr = (int **)malloc(sizeof(int) * num);//마방진 제작을 위한 2차원 배열 동적 할당 시작for (int k = 0; k < num; k++)//...{//...Arr[k] = (int *)malloc(sizeof(int) * num);//...}//2차원 배열 동적 할당 끝msmaker(num, Arr);//마방진 제작show(num, Arr);//마방진 출력free(Arr);//동적 할당한 2차원 배열을 풀어줌resume();//계속 할 것인지를 묻고 아니라면 종료}}void bufferclear()//버퍼를 비우는 함수{while (getchar() != '\n');//'엔터(\n)'가 입력 될 때 까지 그냥 입력처리하여 버퍼를 비움}void inputnum(int *num)//마방진 크기를 입력받는 함수{char mun[100];//최대크기 100으로 선언, 문자형태로 입력받음printf("만들고 싶은 홀수 마방진의 크기를 입력 :");for (;;)//홀수를 입력받을 때 까지 무한루프 돌입{scanf_s("%s", &(*mun), sizeof(mun));//마방진의 크기를 입력받음bufferclear();//불필요한 값을 제거하기 위해 버퍼를 비움if (!isdigit(*mun))//입력받은 값이 숫자가 아닐 경우{printf("홀수숫자를 입력하세요 :");continue;//메시지를 띄우고 다시 루프}*num = atoi(mun);//문자를 숫자로 변환하여 입력printf("\n");if (*num % 2 == 0)//입력받은 수가 짝수일 경우{system("cls");printf("짝수는 불가능, 홀수를 입력 :");//에러메시지 출력}else if (*num % 2 != 0)//입력받은 수가 홀수일 경우{system("cls");break;//루프문 탈출}}}void msmaker(int num, int **Arr)//마방진 연산을 위한 함수{int i = 0;//마방진은 1행, 중간열에서 시작하므로 int j = (num / 2);//i는 0, j는 2로 나눈 값을 저장for (int k = 1; k <= (num*num); k++)//k값은 마방진의 값을 나타냄. 1부터 n*n값까지 루프를 돌며 증가하도록 지정{Arr[i][j] = k;//k값을 마방진의 배열에 집어넣음if ((k % num) == 0)//k값이 입력한 n값의 배수일 경우{i += 1;//i값을 하나 증가시키고continue;//다시 루프를 돎}//k값이 n값의 배수가 아니라면i -= 1;//i값을 1 뺀다if (i < 0)//i가 0보다 작아지게 될 경우{i = num -1;//i에 행의 최대값을 집어넣음. (-1인 이유는 배열은 1이 아니라 0부터 시작하므로)}j += 1;//j값을 1 더한다if (j > num -1)//j가 열 최대값보다 커지게 될 경우 {j = 0;//j에 열의 최소값을 집어넣음. (0인 이유는 i값일 때와상동)}}}void show(int num, int **Arr)//계산한 마방진을 출력하는 함수{int i, j, hsum = 0, diasum = 0;//행 합계, 대각선 합계,int *vsum;//열 합계vsum = (int *)calloc(num, sizeof(int));//열 합계를 저장하기 위한 배열 선언for (i = 0; i < num; i++)//2차원 배열인 마방진을 출력하기 위한 이중 루프문 시작{//i값이 고정되고 j값이 여러번 돌기 때문에 행고정 열변화for (j = 0; j < num; j++){if (Arr[i][j] < 10)//보기좋게 하기 위해 한 자릿수일 경우 공백을 하나 더부여{printf(" %d ", Arr[i][j]);}else{printf("%d ", Arr[i][j]);}hsum += Arr[i][j];//행이 고정되고 열이 변하므로 행의 합계가 구해짐vsum[i] += Arr[j][i];//j값을 앞에 위치시켰으므로 행변화 열고정이 됨//vsum에 고정값인 i값을 이용했으므로 열 합계를 구할 때 마다 같이 하나씩 증가if (i == j)//대각선 합은 i값과 j값이 동일할 때만 더한다{diasum += Arr[i][j];}if (j == num -1)//열이 최대값이 될 경우{printf("          %d행의 합 : %d", i + 1, hsum);//행의 합계를 출력printf("\n");hsum = 0;//다음 행을 구하기 위해 행의 합계를 구하는 변수를 초기화if (i == num -1)//행이 최대값이 될 경우{printf("\n");printf("---열의 합---\n");//열의 합계를 출력for (int k = 0; k < num; k++){printf("%d ", vsum[k]);}}}}}free(vsum);//열의 합계를 구하는 동적 할당 배열을 풀어줌printf("          대각선의 합 : %d\n", diasum);//마지막으로 대각선의 합을 출력printf("\n");}void resume()//모든 작업을 한 후 프로그램을 다시 돌리는가 하는 함수{char input[10];//입력크기 10printf("계속 하신다면 Y, 종료하시려면 N을 입력 :");for (;;){scanf_s("%s", &input, sizeof(input));//입력 받음bufferclear();//버퍼 비움if (isalpha(*input) && islower(*input))//입력받은 문자가 문자이면서 소문자일 경우{*input = toupper(*input);//대문자로 변환하여 입력}if (!isalpha(*input) || strcmp("Y", input) != 0 && strcmp("N", input) != 0)//알파벳이 아니거나, Y 혹은 N이 아니라면{printf("Y 혹은 N을 입력 해 주세요 :");//에러메시지를 출력하고continue;//루프문 다시 돌입}if (!strcmp("Y", input))//입력받은 값이 'Y'일 경우{system("cls");break;//현재 함수를 종료하고 프로그램을 다시 가동}else if (!strcmp("N", input))//입력받은 값이 'N'일 경우{exit(0);//프로그램 종료}}}
